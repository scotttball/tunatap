package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/rs/zerolog/log"
	"github.com/scotttball/tunatap/internal/cluster"
	"github.com/scotttball/tunatap/internal/config"
	"github.com/scotttball/tunatap/internal/kubeconfig"
	"github.com/spf13/cobra"
)

var (
	kubeconfigClusterName string
	kubeconfigOutputPath  string
	kubeconfigPort        int
	kubeconfigNoOCIAuth   bool
	kubeconfigOCIProfile  string
	kubeconfigMerge       bool
)

var kubeconfigCmd = &cobra.Command{
	Use:   "kubeconfig [cluster]",
	Short: "Generate a kubeconfig for a cluster",
	Long: `Generate a kubeconfig file for accessing a cluster through tunatap.

The generated kubeconfig uses OCI exec-auth by default, allowing kubectl to
automatically obtain short-lived tokens via the OCI CLI. This is similar to
the kubeconfig generated by 'oci ce cluster create-kubeconfig'.

Examples:
  # Generate kubeconfig to stdout
  tunatap kubeconfig my-cluster

  # Save to a specific file
  tunatap kubeconfig my-cluster -o ~/.kube/tunatap-my-cluster.yaml

  # Merge into default kubeconfig
  tunatap kubeconfig my-cluster --merge

  # Generate without OCI auth (insecure mode)
  tunatap kubeconfig my-cluster --no-oci-auth`,
	RunE: runKubeconfig,
	Args: cobra.MaximumNArgs(1),
}

func init() {
	rootCmd.AddCommand(kubeconfigCmd)

	kubeconfigCmd.Flags().StringVarP(&kubeconfigClusterName, "cluster", "c", "", "cluster name")
	kubeconfigCmd.Flags().StringVarP(&kubeconfigOutputPath, "output", "o", "", "output file path (default: stdout)")
	kubeconfigCmd.Flags().IntVarP(&kubeconfigPort, "port", "p", 6443, "local port for tunnel endpoint")
	kubeconfigCmd.Flags().BoolVar(&kubeconfigNoOCIAuth, "no-oci-auth", false, "disable OCI exec-auth (use insecure mode)")
	kubeconfigCmd.Flags().StringVar(&kubeconfigOCIProfile, "oci-profile", "", "OCI config profile for exec-auth")
	kubeconfigCmd.Flags().BoolVar(&kubeconfigMerge, "merge", false, "merge into existing kubeconfig (~/.kube/config)")
}

func runKubeconfig(cmd *cobra.Command, args []string) error {
	// Load configuration
	cfg, err := config.ReadConfig(GetConfigFile())
	if err != nil {
		return fmt.Errorf("failed to read config: %w", err)
	}

	// Configure globals
	if err := config.ConfigureGlobals(cfg); err != nil {
		return fmt.Errorf("failed to configure globals: %w", err)
	}

	// Determine cluster name
	clusterToUse := kubeconfigClusterName
	if clusterToUse == "" && len(args) > 0 {
		clusterToUse = args[0]
	}

	// Select cluster
	selectedCluster, err := selectCluster(cfg, clusterToUse)
	if err != nil {
		return err
	}

	// Create OCI client for cluster validation
	ociClient, err := createOCIClient(cfg, selectedCluster.Region)
	if err != nil {
		return fmt.Errorf("failed to create OCI client: %w", err)
	}

	// Validate cluster to get OCID if not set
	if err := cluster.ValidateAndUpdateCluster(cmd.Context(), ociClient, selectedCluster, false, kubeconfigPort); err != nil {
		log.Warn().Err(err).Msg("Cluster validation failed, some features may not work")
	}

	// Determine port
	port := kubeconfigPort
	if selectedCluster.LocalPort != nil && *selectedCluster.LocalPort > 0 {
		port = *selectedCluster.LocalPort
	}

	// Determine OCI profile
	profile := kubeconfigOCIProfile
	if profile == "" {
		profile = cfg.OCIProfile
	}

	// Generate kubeconfig
	var kubecfg *kubeconfig.Kubeconfig
	if selectedCluster.Ocid != nil && *selectedCluster.Ocid != "" && !kubeconfigNoOCIAuth {
		log.Info().Msg("Generating kubeconfig with OCI exec-auth")
		kubecfg = kubeconfig.NewOCIKubeconfigForTunnel(
			selectedCluster.ClusterName,
			*selectedCluster.Ocid,
			selectedCluster.Region,
			port,
			profile,
		)
	} else {
		log.Info().Msg("Generating kubeconfig without OCI auth (insecure mode)")
		kubecfg = kubeconfig.NewInsecureKubeconfig(selectedCluster.ClusterName, port)
	}

	// Handle output
	if kubeconfigMerge {
		return mergeKubeconfig(kubecfg)
	}

	if kubeconfigOutputPath != "" {
		if err := kubecfg.WriteToFile(kubeconfigOutputPath); err != nil {
			return fmt.Errorf("failed to write kubeconfig: %w", err)
		}
		log.Info().Msgf("Kubeconfig written to %s", kubeconfigOutputPath)
		fmt.Printf("Kubeconfig written to: %s\n", kubeconfigOutputPath)
		fmt.Printf("Use: export KUBECONFIG=%s\n", kubeconfigOutputPath)
		return nil
	}

	// Output to stdout
	yaml, err := kubecfg.ToYAML()
	if err != nil {
		return fmt.Errorf("failed to generate YAML: %w", err)
	}
	fmt.Print(yaml)
	return nil
}

// mergeKubeconfig merges the generated kubeconfig into ~/.kube/config
func mergeKubeconfig(newKubecfg *kubeconfig.Kubeconfig) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	kubeconfigPath := filepath.Join(home, ".kube", "config")

	// Load existing kubeconfig if it exists
	var existing *kubeconfig.Kubeconfig
	if _, err := os.Stat(kubeconfigPath); err == nil {
		existing, err = kubeconfig.LoadFromFile(kubeconfigPath)
		if err != nil {
			return fmt.Errorf("failed to load existing kubeconfig: %w", err)
		}
	} else {
		existing = kubeconfig.NewKubeconfig()
	}

	// Merge
	merged := kubeconfig.MergeKubeconfigs(existing, newKubecfg)

	// Set current context to the new cluster
	merged.SetCurrentContext(newKubecfg.CurrentContext)

	// Write back
	if err := merged.WriteToFile(kubeconfigPath); err != nil {
		return fmt.Errorf("failed to write kubeconfig: %w", err)
	}

	log.Info().Msgf("Merged kubeconfig into %s", kubeconfigPath)
	fmt.Printf("Context '%s' added to %s\n", newKubecfg.CurrentContext, kubeconfigPath)
	fmt.Printf("Current context set to: %s\n", newKubecfg.CurrentContext)
	return nil
}
