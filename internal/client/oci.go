package client

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/oracle/oci-go-sdk/v65/bastion"
	"github.com/oracle/oci-go-sdk/v65/common"
	"github.com/oracle/oci-go-sdk/v65/common/auth"
	"github.com/oracle/oci-go-sdk/v65/containerengine"
	"github.com/oracle/oci-go-sdk/v65/identity"
	"github.com/oracle/oci-go-sdk/v65/objectstorage"
	"github.com/rs/zerolog/log"
)

// AuthType represents the type of OCI authentication to use.
type AuthType string

const (
	// AuthTypeAuto automatically detects the best authentication method.
	AuthTypeAuto AuthType = "auto"
	// AuthTypeConfigFile uses the OCI config file (~/.oci/config).
	AuthTypeConfigFile AuthType = "config"
	// AuthTypeInstancePrincipal uses instance principal authentication (for OCI compute instances).
	AuthTypeInstancePrincipal AuthType = "instance_principal"
	// AuthTypeSecurityToken uses security token authentication (from `oci session authenticate`).
	AuthTypeSecurityToken AuthType = "security_token"
	// AuthTypeResourcePrincipal uses resource principal authentication (for OCI functions, etc.).
	AuthTypeResourcePrincipal AuthType = "resource_principal"
)

// OCIClient wraps multiple OCI SDK clients.
type OCIClient struct {
	configProvider     common.ConfigurationProvider
	identityClient     identity.IdentityClient
	bastionClient      bastion.BastionClient
	containerClient    containerengine.ContainerEngineClient
	objectStorageClient objectstorage.ObjectStorageClient
}

// NewOCIClient creates a new OCI client with the given config provider.
func NewOCIClient(configProvider *common.ConfigurationProvider) (*OCIClient, error) {
	client := &OCIClient{
		configProvider: *configProvider,
	}

	var err error

	client.identityClient, err = identity.NewIdentityClientWithConfigurationProvider(*configProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to create identity client: %w", err)
	}

	client.bastionClient, err = bastion.NewBastionClientWithConfigurationProvider(*configProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to create bastion client: %w", err)
	}

	client.containerClient, err = containerengine.NewContainerEngineClientWithConfigurationProvider(*configProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to create container engine client: %w", err)
	}

	client.objectStorageClient, err = objectstorage.NewObjectStorageClientWithConfigurationProvider(*configProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to create object storage client: %w", err)
	}

	return client, nil
}

// NewOCIClientWithProfile creates a new OCI client using a specific profile.
func NewOCIClientWithProfile(configPath, profile string) (*OCIClient, error) {
	configProvider := common.CustomProfileConfigProvider(configPath, profile)
	return NewOCIClient(&configProvider)
}

// NewOCIClientWithAuthType creates a new OCI client with the specified authentication type.
func NewOCIClientWithAuthType(authType AuthType, configPath, profile string) (*OCIClient, error) {
	switch authType {
	case AuthTypeConfigFile:
		return NewOCIClientWithProfile(configPath, profile)

	case AuthTypeInstancePrincipal:
		return NewOCIClientWithInstancePrincipal()

	case AuthTypeSecurityToken:
		return NewOCIClientWithSecurityToken(configPath, profile)

	case AuthTypeResourcePrincipal:
		return NewOCIClientWithResourcePrincipal()

	case AuthTypeAuto:
		return NewOCIClientAuto(configPath, profile)

	default:
		return nil, fmt.Errorf("unknown auth type: %s", authType)
	}
}

// NewOCIClientWithInstancePrincipal creates a new OCI client using instance principal authentication.
// This is used when running on an OCI compute instance with a configured dynamic group.
func NewOCIClientWithInstancePrincipal() (*OCIClient, error) {
	log.Debug().Msg("Using instance principal authentication")

	configProvider, err := auth.InstancePrincipalConfigurationProvider()
	if err != nil {
		return nil, fmt.Errorf("failed to create instance principal provider: %w", err)
	}

	var provider common.ConfigurationProvider = configProvider
	return NewOCIClient(&provider)
}

// NewOCIClientWithResourcePrincipal creates a new OCI client using resource principal authentication.
// This is used when running in OCI Functions or other managed environments.
func NewOCIClientWithResourcePrincipal() (*OCIClient, error) {
	log.Debug().Msg("Using resource principal authentication")

	configProvider, err := auth.ResourcePrincipalConfigurationProvider()
	if err != nil {
		return nil, fmt.Errorf("failed to create resource principal provider: %w", err)
	}

	var provider common.ConfigurationProvider = configProvider
	return NewOCIClient(&provider)
}

// NewOCIClientWithSecurityToken creates a new OCI client using security token authentication.
// This uses tokens generated by `oci session authenticate` for SSO/SAML flows.
func NewOCIClientWithSecurityToken(configPath, profile string) (*OCIClient, error) {
	log.Debug().Msg("Using security token authentication")

	// Check for session token file
	if configPath == "" {
		home, _ := os.UserHomeDir()
		configPath = filepath.Join(home, ".oci", "config")
	}

	configProvider, err := common.ConfigurationProviderForSessionToken(configPath, profile)
	if err != nil {
		return nil, fmt.Errorf("failed to create security token provider: %w", err)
	}

	var provider common.ConfigurationProvider = configProvider
	return NewOCIClient(&provider)
}

// NewOCIClientAuto creates a new OCI client by auto-detecting the best authentication method.
// The detection order is:
// 1. Security token (if session token file exists and is valid)
// 2. Instance principal (if running on OCI and metadata service is available)
// 3. Resource principal (if OCI_RESOURCE_PRINCIPAL_VERSION env var is set)
// 4. Config file (fallback to standard config file authentication)
func NewOCIClientAuto(configPath, profile string) (*OCIClient, error) {
	log.Debug().Msg("Auto-detecting OCI authentication method")

	// Try security token first (SSO sessions)
	if hasValidSecurityToken(configPath, profile) {
		log.Info().Msg("Using security token authentication (SSO)")
		client, err := NewOCIClientWithSecurityToken(configPath, profile)
		if err == nil {
			return client, nil
		}
		log.Debug().Err(err).Msg("Security token auth failed, trying next method")
	}

	// Check for resource principal (OCI Functions, etc.)
	if os.Getenv("OCI_RESOURCE_PRINCIPAL_VERSION") != "" {
		log.Info().Msg("Using resource principal authentication")
		client, err := NewOCIClientWithResourcePrincipal()
		if err == nil {
			return client, nil
		}
		log.Debug().Err(err).Msg("Resource principal auth failed, trying next method")
	}

	// Try instance principal (OCI compute instances)
	if isRunningOnOCI() {
		log.Info().Msg("Using instance principal authentication")
		client, err := NewOCIClientWithInstancePrincipal()
		if err == nil {
			return client, nil
		}
		log.Debug().Err(err).Msg("Instance principal auth failed, trying config file")
	}

	// Fall back to config file
	log.Info().Msg("Using config file authentication")
	return NewOCIClientWithProfile(configPath, profile)
}

// hasValidSecurityToken checks if a valid security token exists.
func hasValidSecurityToken(configPath, profile string) bool {
	if configPath == "" {
		home, _ := os.UserHomeDir()
		configPath = filepath.Join(home, ".oci", "config")
	}

	// Try to create a session token provider and check if it's valid
	provider, err := common.ConfigurationProviderForSessionToken(configPath, profile)
	if err != nil {
		return false
	}

	// Try to get the private key which will validate the token
	_, err = provider.PrivateRSAKey()
	return err == nil
}

// isRunningOnOCI checks if the current environment is likely an OCI compute instance.
func isRunningOnOCI() bool {
	// Check for OCI metadata service availability
	// This is a simple heuristic - the instance principal provider will do the real validation

	// Check common OCI environment indicators
	if os.Getenv("OCI_RESOURCE_PRINCIPAL_VERSION") != "" {
		return true
	}

	// Check if running in a container with instance principal configured
	if os.Getenv("OCI_CLI_AUTH") == "instance_principal" {
		return true
	}

	// Note: We don't actually probe the metadata service here as that would
	// add latency. The instance principal provider will handle that.
	return false
}

// GetAuthType returns the authentication type being used by this client.
func (c *OCIClient) GetAuthType() AuthType {
	// Try to determine auth type from the config provider
	_, err := c.configProvider.KeyID()
	if err != nil {
		// If KeyID fails, it might be instance/resource principal
		return AuthTypeInstancePrincipal
	}
	return AuthTypeConfigFile
}

// SetRegion sets the region for all clients.
func (c *OCIClient) SetRegion(region string) {
	c.identityClient.SetRegion(region)
	c.bastionClient.SetRegion(region)
	c.containerClient.SetRegion(region)
	c.objectStorageClient.SetRegion(region)
}

// GetNamespace returns the Object Storage namespace for a tenancy.
func (c *OCIClient) GetNamespace(ctx context.Context, tenancyOcid string) (string, error) {
	request := objectstorage.GetNamespaceRequest{
		CompartmentId: &tenancyOcid,
	}

	response, err := c.objectStorageClient.GetNamespace(ctx, request)
	if err != nil {
		return "", fmt.Errorf("failed to get namespace: %w", err)
	}

	return *response.Value, nil
}

// GetObject retrieves an object from Object Storage.
func (c *OCIClient) GetObject(ctx context.Context, namespace, bucket, object string) ([]byte, error) {
	request := objectstorage.GetObjectRequest{
		NamespaceName: &namespace,
		BucketName:    &bucket,
		ObjectName:    &object,
	}

	response, err := c.objectStorageClient.GetObject(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to get object: %w", err)
	}
	defer response.Content.Close()

	data, err := io.ReadAll(response.Content)
	if err != nil {
		return nil, fmt.Errorf("failed to read object content: %w", err)
	}

	return data, nil
}

// GetCompartmentIdByPath finds a compartment by path (e.g., "parent/child/grandchild").
func (c *OCIClient) GetCompartmentIdByPath(ctx context.Context, tenancyOcid, path string) (*string, error) {
	parts := strings.Split(path, "/")
	currentCompartmentId := tenancyOcid

	for _, part := range parts {
		compartmentId, err := c.findCompartmentByName(ctx, currentCompartmentId, part)
		if err != nil {
			return nil, err
		}
		currentCompartmentId = *compartmentId
	}

	return &currentCompartmentId, nil
}

// findCompartmentByName finds a compartment by name within a parent compartment.
func (c *OCIClient) findCompartmentByName(ctx context.Context, parentId, name string) (*string, error) {
	request := identity.ListCompartmentsRequest{
		CompartmentId: &parentId,
		Name:          &name,
	}

	response, err := c.identityClient.ListCompartments(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to list compartments: %w", err)
	}

	if len(response.Items) == 0 {
		return nil, fmt.Errorf("compartment '%s' not found in %s", name, parentId)
	}

	return response.Items[0].Id, nil
}

// FetchClusterId finds a cluster OCID by name in a compartment.
func (c *OCIClient) FetchClusterId(ctx context.Context, compartmentId, clusterName string) (*string, error) {
	request := containerengine.ListClustersRequest{
		CompartmentId: &compartmentId,
		Name:          &clusterName,
	}

	response, err := c.containerClient.ListClusters(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to list clusters: %w", err)
	}

	for _, cluster := range response.Items {
		if *cluster.Name == clusterName {
			return cluster.Id, nil
		}
	}

	return nil, fmt.Errorf("cluster '%s' not found in compartment %s", clusterName, compartmentId)
}

// GetCluster retrieves cluster details by OCID.
func (c *OCIClient) GetCluster(ctx context.Context, clusterId string) (*containerengine.Cluster, error) {
	request := containerengine.GetClusterRequest{
		ClusterId: &clusterId,
	}

	response, err := c.containerClient.GetCluster(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to get cluster: %w", err)
	}

	return &response.Cluster, nil
}

// ListBastions lists all bastions in a compartment.
func (c *OCIClient) ListBastions(ctx context.Context, compartmentId string) ([]bastion.BastionSummary, error) {
	request := bastion.ListBastionsRequest{
		CompartmentId: &compartmentId,
	}

	response, err := c.bastionClient.ListBastions(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to list bastions: %w", err)
	}

	return response.Items, nil
}

// GetBastion retrieves bastion details by OCID.
func (c *OCIClient) GetBastion(ctx context.Context, bastionId string) (*bastion.Bastion, error) {
	request := bastion.GetBastionRequest{
		BastionId: &bastionId,
	}

	response, err := c.bastionClient.GetBastion(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to get bastion: %w", err)
	}

	return &response.Bastion, nil
}

// CreateSession creates a new bastion session.
func (c *OCIClient) CreateSession(ctx context.Context, bastionId string, sessionDetails bastion.CreateSessionDetails) (*bastion.Session, error) {
	request := bastion.CreateSessionRequest{
		CreateSessionDetails: sessionDetails,
	}

	response, err := c.bastionClient.CreateSession(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	return &response.Session, nil
}

// GetSession retrieves session details by OCID.
func (c *OCIClient) GetSession(ctx context.Context, bastionId, sessionId string) (*bastion.Session, error) {
	request := bastion.GetSessionRequest{
		SessionId: &sessionId,
	}

	response, err := c.bastionClient.GetSession(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to get session: %w", err)
	}

	return &response.Session, nil
}

// ListSessions lists sessions for a bastion.
func (c *OCIClient) ListSessions(ctx context.Context, bastionId string) ([]bastion.SessionSummary, error) {
	request := bastion.ListSessionsRequest{
		BastionId: &bastionId,
	}

	response, err := c.bastionClient.ListSessions(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to list sessions: %w", err)
	}

	return response.Items, nil
}

// DeleteSession deletes a bastion session.
func (c *OCIClient) DeleteSession(ctx context.Context, bastionId, sessionId string) error {
	request := bastion.DeleteSessionRequest{
		SessionId: &sessionId,
	}

	_, err := c.bastionClient.DeleteSession(ctx, request)
	if err != nil {
		return fmt.Errorf("failed to delete session: %w", err)
	}

	log.Debug().Msgf("Deleted session: %s", sessionId)
	return nil
}

// WaitForSessionActive waits for a session to become active.
func (c *OCIClient) WaitForSessionActive(ctx context.Context, bastionId, sessionId string) (*bastion.Session, error) {
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			session, err := c.GetSession(ctx, bastionId, sessionId)
			if err != nil {
				return nil, err
			}

			switch session.LifecycleState {
			case bastion.SessionLifecycleStateActive:
				return session, nil
			case bastion.SessionLifecycleStateDeleted, bastion.SessionLifecycleStateFailed:
				return nil, fmt.Errorf("session entered %s state", session.LifecycleState)
			}

			log.Debug().Msgf("Session state: %s, waiting...", session.LifecycleState)
		}
	}
}
